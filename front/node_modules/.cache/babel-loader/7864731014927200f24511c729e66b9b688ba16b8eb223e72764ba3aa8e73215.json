{"ast":null,"code":"/**\n * Service de journalisation des erreurs\n * Centralise la gestion et l'enregistrement des erreurs de l'application\n */\n\n// Configuration du niveau de journalisation\nconst LOG_LEVELS = {\n  ERROR: 'error',\n  WARNING: 'warning',\n  INFO: 'info'\n};\n\n// Configuration de base\nconst config = {\n  // Activer/désactiver la journalisation en console\n  consoleLogging: true,\n  // Activer/désactiver l'envoi des erreurs au serveur\n  serverLogging: process.env.NODE_ENV === 'production',\n  // URL de l'API de journalisation (à configurer selon votre backend)\n  loggingEndpoint: 'http://127.0.0.1:8000/api/logs',\n  // Niveau minimum de journalisation\n  minimumLevel: LOG_LEVELS.ERROR\n};\n\n/**\n * Enregistre une erreur dans la console\n * @param {Error} error - L'erreur à journaliser\n * @param {Object} context - Informations contextuelles supplémentaires\n * @param {string} level - Niveau de journalisation\n */\nconst logToConsole = (error, context = {}, level = LOG_LEVELS.ERROR) => {\n  if (!config.consoleLogging) return;\n  const timestamp = new Date().toISOString();\n  switch (level) {\n    case LOG_LEVELS.ERROR:\n      console.error(`[${timestamp}] ERROR:`, error, context);\n      break;\n    case LOG_LEVELS.WARNING:\n      console.warn(`[${timestamp}] WARNING:`, error, context);\n      break;\n    case LOG_LEVELS.INFO:\n      console.info(`[${timestamp}] INFO:`, error, context);\n      break;\n    default:\n      console.log(`[${timestamp}] LOG:`, error, context);\n  }\n};\n\n/**\n * Envoie une erreur au serveur pour journalisation\n * @param {Error} error - L'erreur à journaliser\n * @param {Object} context - Informations contextuelles supplémentaires\n * @param {string} level - Niveau de journalisation\n */\nconst logToServer = async (error, context = {}, level = LOG_LEVELS.ERROR) => {\n  if (!config.serverLogging) return;\n  try {\n    const errorData = {\n      message: error.message || 'Erreur inconnue',\n      stack: error.stack,\n      timestamp: new Date().toISOString(),\n      level,\n      context: {\n        ...context,\n        url: window.location.href,\n        userAgent: navigator.userAgent\n        // Ajouter d'autres informations utiles du contexte\n      }\n    };\n\n    // Utiliser fetch plutôt que l'instance axios pour éviter les boucles infinies\n    // si l'erreur provient d'axios\n    await fetch(config.loggingEndpoint, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify(errorData),\n      // Ne pas attendre la réponse pour ne pas bloquer l'utilisateur\n      keepalive: true\n    });\n  } catch (logError) {\n    // Erreur silencieuse pour éviter les boucles infinies\n    if (config.consoleLogging) {\n      console.error('Erreur lors de la journalisation au serveur:', logError);\n    }\n  }\n};\n\n/**\n * Journalise une erreur\n * @param {Error} error - L'erreur à journaliser\n * @param {Object} context - Informations contextuelles supplémentaires\n * @param {string} level - Niveau de journalisation\n */\nconst logError = async (error, context = {}, level = LOG_LEVELS.ERROR) => {\n  // Vérifier si le niveau correspond au minimum requis\n  if (Object.values(LOG_LEVELS).indexOf(level) < Object.values(LOG_LEVELS).indexOf(config.minimumLevel)) {\n    return;\n  }\n\n  // Journaliser en console\n  logToConsole(error, context, level);\n\n  // Journaliser au serveur\n  await logToServer(error, context, level);\n};\n\n// Exporter les fonctions et constantes utiles\nexport default {\n  logError,\n  LOG_LEVELS,\n  // Méthodes spécifiques pour différents niveaux\n  error: (error, context) => logError(error, context, LOG_LEVELS.ERROR),\n  warning: (error, context) => logError(error, context, LOG_LEVELS.WARNING),\n  info: (error, context) => logError(error, context, LOG_LEVELS.INFO),\n  // Configuration\n  setConfig: newConfig => {\n    Object.assign(config, newConfig);\n  }\n};","map":{"version":3,"names":["LOG_LEVELS","ERROR","WARNING","INFO","config","consoleLogging","serverLogging","process","env","NODE_ENV","loggingEndpoint","minimumLevel","logToConsole","error","context","level","timestamp","Date","toISOString","console","warn","info","log","logToServer","errorData","message","stack","url","window","location","href","userAgent","navigator","fetch","method","headers","body","JSON","stringify","keepalive","logError","Object","values","indexOf","warning","setConfig","newConfig","assign"],"sources":["/Users/mac/Downloads/APP_NS_V1/dev_projet/sauvegardegit/front/src/services/errorLogger.js"],"sourcesContent":["/**\n * Service de journalisation des erreurs\n * Centralise la gestion et l'enregistrement des erreurs de l'application\n */\n\n// Configuration du niveau de journalisation\nconst LOG_LEVELS = {\n    ERROR: 'error',\n    WARNING: 'warning',\n    INFO: 'info'\n  };\n  \n  // Configuration de base\n  const config = {\n    // Activer/désactiver la journalisation en console\n    consoleLogging: true,\n    // Activer/désactiver l'envoi des erreurs au serveur\n    serverLogging: process.env.NODE_ENV === 'production',\n    // URL de l'API de journalisation (à configurer selon votre backend)\n    loggingEndpoint: 'http://127.0.0.1:8000/api/logs',\n    // Niveau minimum de journalisation\n    minimumLevel: LOG_LEVELS.ERROR\n  };\n  \n  /**\n   * Enregistre une erreur dans la console\n   * @param {Error} error - L'erreur à journaliser\n   * @param {Object} context - Informations contextuelles supplémentaires\n   * @param {string} level - Niveau de journalisation\n   */\n  const logToConsole = (error, context = {}, level = LOG_LEVELS.ERROR) => {\n    if (!config.consoleLogging) return;\n  \n    const timestamp = new Date().toISOString();\n    \n    switch (level) {\n      case LOG_LEVELS.ERROR:\n        console.error(`[${timestamp}] ERROR:`, error, context);\n        break;\n      case LOG_LEVELS.WARNING:\n        console.warn(`[${timestamp}] WARNING:`, error, context);\n        break;\n      case LOG_LEVELS.INFO:\n        console.info(`[${timestamp}] INFO:`, error, context);\n        break;\n      default:\n        console.log(`[${timestamp}] LOG:`, error, context);\n    }\n  };\n  \n  /**\n   * Envoie une erreur au serveur pour journalisation\n   * @param {Error} error - L'erreur à journaliser\n   * @param {Object} context - Informations contextuelles supplémentaires\n   * @param {string} level - Niveau de journalisation\n   */\n  const logToServer = async (error, context = {}, level = LOG_LEVELS.ERROR) => {\n    if (!config.serverLogging) return;\n  \n    try {\n      const errorData = {\n        message: error.message || 'Erreur inconnue',\n        stack: error.stack,\n        timestamp: new Date().toISOString(),\n        level,\n        context: {\n          ...context,\n          url: window.location.href,\n          userAgent: navigator.userAgent,\n          // Ajouter d'autres informations utiles du contexte\n        }\n      };\n  \n      // Utiliser fetch plutôt que l'instance axios pour éviter les boucles infinies\n      // si l'erreur provient d'axios\n      await fetch(config.loggingEndpoint, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(errorData),\n        // Ne pas attendre la réponse pour ne pas bloquer l'utilisateur\n        keepalive: true\n      });\n    } catch (logError) {\n      // Erreur silencieuse pour éviter les boucles infinies\n      if (config.consoleLogging) {\n        console.error('Erreur lors de la journalisation au serveur:', logError);\n      }\n    }\n  };\n  \n  /**\n   * Journalise une erreur\n   * @param {Error} error - L'erreur à journaliser\n   * @param {Object} context - Informations contextuelles supplémentaires\n   * @param {string} level - Niveau de journalisation\n   */\n  const logError = async (error, context = {}, level = LOG_LEVELS.ERROR) => {\n    // Vérifier si le niveau correspond au minimum requis\n    if (Object.values(LOG_LEVELS).indexOf(level) < \n        Object.values(LOG_LEVELS).indexOf(config.minimumLevel)) {\n      return;\n    }\n  \n    // Journaliser en console\n    logToConsole(error, context, level);\n  \n    // Journaliser au serveur\n    await logToServer(error, context, level);\n  };\n  \n  // Exporter les fonctions et constantes utiles\n  export default {\n    logError,\n    LOG_LEVELS,\n    // Méthodes spécifiques pour différents niveaux\n    error: (error, context) => logError(error, context, LOG_LEVELS.ERROR),\n    warning: (error, context) => logError(error, context, LOG_LEVELS.WARNING),\n    info: (error, context) => logError(error, context, LOG_LEVELS.INFO),\n    // Configuration\n    setConfig: (newConfig) => {\n      Object.assign(config, newConfig);\n    }\n  };"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}